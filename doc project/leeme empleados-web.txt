Esta versión tira de spring boot 2.0

Este commit está configurado y funcionando para que los retrys sean implícitos. Necesitamos el server
eureka levantado y varios empleados-service (por ejemplo con los commit cambiamos post por put)

Los retrys están configurados en el fichero de configuración, hemos añadido el jar de spring-retry al pom
 y utilizado un RestTemplate LoadBalanced (funciona además out-of-the-box con zuul y feign, pero no con un 
 LoadBalancerClient). Como usamos el RT LB cableamos la autenticación al crearlo a admin - admin.

Funcionan los get, el insert, el update y el delete.

Hemos creado una jerarquía de excepciones y transformamos los códigos de error en excepciones de
aplicación en el servicio que son capturadas por el controlador para mostrar errores sensibles. Esto
de momento funciona sólo con el servicio ribbon (no sé cómo sacar el código de estado de una excepción
feign). En el delete del servicio Ribbon tenemos un ejemplo simple de gestión de excepciones y códigos,
para los demás hay hecho un ResponseErrorHandler.

Ribbon lo configuramos a nivel de fichero de config (aunque podría hacerse también mediante una
clase @Configuration, ver https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-ribbon.html).
Es importante hacer notar que la configuración se utiliza porque el prefijo de configuración (empleados-service)
coincide con el alias del servicio al que queremos acceder. Por ello cuando usamos el LoadBalancerClient con ese
alias se activa la configuración para ese cliente.

Usamos Java Config para generar todos los beans de la app. Accediendo directamente a localhost:3333 ya aparecen
los dos enlaces posibles. El /logout funciona con post (en index.jsp) o con get (/logout).

	- EmpleadosWebService: clase de negocio que interactúa con el microservicio. 
	  Como ahora no usamos @LoadBalanced, inyectamos en su lugar un LoadBalancerClient
	  para consultar al servidor Eureka con balance de carga y obtener la Url del servicio
	  de empleados a partir de su alias (visto en https://www.javainuse.com/spring/spring_ribbon). 
	  Para conseguir seguridad dinámica inyectamos el RestTemplateBuilder 
	  y para cada petición recuperamos el principal y la password y con ellos generamos 
	  un RestTemplate autenticado.
	  
	  Implementa un método nuevo (getAllEmpleadosWithFeign()) que utiliza Feign para recuperar
	  todos los empleados
	  
	- EmpleadosWebSecurityConfig: configuración de seguridad. Añadimos {noop} como prefijo al
	  declarar las contraseñas (transparente para el cliente) para saltarnos el requerimiento
	  de security 5.x de que las contraseñas estén hashcodeadas.
	
	- EmpleadosWebController: controlador. Delega en EmpleadosWebService para la interacción
	  con el micro servicio.
	  
	- EmpleadosWebServer: inicia el servidor y hace de configurador de beans.
	  
	- EmpleadoValidator: validador spring de cif, nombre y apps obligatorios y de edad positiva. Utiliza
	  el fichero de recursos para los parámetros de los mensajes (Name ó Nombre, por ejemplo).
	  
	- EmpleadosWebServiceRibbonDeclarado: Service que usa RestTemplate LoadBalanced y retries implícitos.

- Sobre el logout (cogido del proyecto 'empleados hb spring mvc sec ws 4' del workspace
'spring completo'): parece que desde la versión 4 de spring security 
el logout por defecto sólo
funciona cuando hacemos una petición de logout POST enviando un csrf (ver apuntes de seguridad
spring). Para habilitar el logout get lo podemos hacer deshabilitando el csrf (como hacemos
en el proyecto mencionado al configurar la seguridad de forma declarativa) o mediante el código que
se encuentra en la clase WebSecurityConfig del mismo proyecto (que respeta el csrf).