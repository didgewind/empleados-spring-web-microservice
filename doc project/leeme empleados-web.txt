Esta versión tira de spring boot 2.0

* empleados web (puerto 3333): app web con seguridad (profe o admin) que tira de los microservicios
de empleados y departamentos. El acceso a empleados está capado porque no hay versión
de este microservicio que trabaje con oauth2 (habría que implementarlo igual que en
departamentos).

La seguridad en esta rama la implementamos con oauth2. En este commit usamos un Grant
Type Authorization Code, igual que en el commit anterior, pero ahora usamos las credenciales
finales para acceder al servicio de departamentos.

Tenemos un servidor de autenticación
(oauth2) contra el que nos autenticamos y de donde obtenemos el Principal con una llamada
implícita (lo hace por debajo el código spring) a la url que mencionamos más abajo. El flujo
de autenticación es, al intentar acceder a una zona protegida de la app el spring oauth2
salta y se conecta con el server de autenticación. Tras autenticarnos el propio server nos
pregunta si autorizamos a la app a acceder a nuestros recursos, e internamente negocia con
la app web la obtención del código de autorización, el token de acceso y seguidamente el
Principal que se ha autenticado (mediante una consulta a su url /auth/user, definida en el .yml 
con la clave security.oauth2.resource.userInfoUri=http://localhost:9999/auth/user. Sobre ese 
Principal se aplicarán las políticas de autorización definidas en la configuración de seguridad.

Más tarde reutilizamos estas credenciales para acceder al servicio de departamentos
(con la clase DepartamentosServiceOAuth2)

Hay que hacer notar que ahora los usuarios, roles y passwords se declaran únicamente en el server
de autenticación. El resto de servicios definen únicamente las autorizaciones en función de roles.

También estamos usando Feign (peticiones rest declarativas). Creamos el cliente Feign manualmente
por cada petición, para poder propagar las credenciales.

El servicio web está refactorizado para separar el código Feign del que utiliza directamente Ribbon.

Hemos creado una jerarquía de excepciones y transformamos los códigos de error en excepciones de
aplicación en el servicio que son capturadas por el controlador para mostrar errores sensibles. Esto
de momento funciona sólo con el servicio ribbon (no sé cómo sacar el código de estado de una excepción
feign). En el delete del servicio Ribbon tenemos un ejemplo simple de gestión de excepciones y códigos,
para los demás hay hecho un ResponseErrorHandler.

Ribbon lo configuramos a nivel de fichero de config (aunque podría hacerse también mediante una
clase @Configuration, ver https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-ribbon.html).
Es importante hacer notar que la configuración se utiliza porque el prefijo de configuración (empleados-service)
coincide con el alias del servicio al que queremos acceder. Por ello cuando usamos el LoadBalancerClient con ese
alias se activa la configuración para ese cliente.

Implementamos retries usando spring-retry de forma explícita (parece que los retrys automáticos sólo funcionan
con zuul y feign, 
ver https://stackoverflow.com/questions/27468697/spring-cloud-with-resttemplate-ribbon-eureka-retry-when-server-not-available
y https://stackoverflow.com/questions/33765049/spring-cloud-getting-retry-working-in-resttemplate).
Para ello marcamos la clase @Configuration con @EnableRetry y la clase WebServiceRibbon con @Retryable

Usamos Java Config para generar todos los beans de la app. Accediendo directamente a localhost:3333 ya aparecen
los dos enlaces posibles. El /logout funciona con post (en index.jsp) o con get (/logout).

	- EmpleadosWebService: clase de negocio que interactúa con el microservicio. 
	  Como ahora no usamos @LoadBalanced, inyectamos en su lugar un LoadBalancerClient
	  para consultar al servidor Eureka con balance de carga y obtener la Url del servicio
	  de empleados a partir de su alias (visto en https://www.javainuse.com/spring/spring_ribbon). 
	  Para conseguir seguridad dinámica inyectamos el RestTemplateBuilder 
	  y para cada petición recuperamos el principal y la password y con ellos generamos 
	  un RestTemplate autenticado.
	  
	  Implementa un método nuevo (getAllEmpleadosWithFeign()) que utiliza Feign para recuperar
	  todos los empleados
	  
	- EmpleadosWebSecurityConfig: configuración de seguridad. Añadimos {noop} como prefijo al
	  declarar las contraseñas (transparente para el cliente) para saltarnos el requerimiento
	  de security 5.x de que las contraseñas estén hashcodeadas.
	
	- EmpleadosWebController: controlador. Delega en EmpleadosWebService para la interacción
	  con el micro servicio.
	  
	- EmpleadosWebServer: inicia el servidor y hace de configurador de beans.
	  
	- EmpleadoValidator: validador spring de cif, nombre y apps obligatorios y de edad positiva. Utiliza
	  el fichero de recursos para los parámetros de los mensajes (Name ó Nombre, por ejemplo).

- Sobre el logout (cogido del proyecto 'empleados hb spring mvc sec ws 4' del workspace
'spring completo'): parece que desde la versión 4 de spring security 
el logout por defecto sólo
funciona cuando hacemos una petición de logout POST enviando un csrf (ver apuntes de seguridad
spring). Para habilitar el logout get lo podemos hacer deshabilitando el csrf (como hacemos
en el proyecto mencionado al configurar la seguridad de forma declarativa) o mediante el código que
se encuentra en la clase WebSecurityConfig del mismo proyecto (que respeta el csrf).